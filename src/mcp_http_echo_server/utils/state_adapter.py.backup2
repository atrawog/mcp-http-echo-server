"""State adapter for dual-mode (stateful/stateless) operation."""

import logging
from typing import Any, Optional
from fastmcp import Context

logger = logging.getLogger(__name__)


class StateAdapter:
    """Adapts state operations for both stateful and stateless modes."""
    
    @staticmethod
    def _get_session_manager(ctx: Context):
        """Get the session manager from context if available."""
        # Try to get the server instance from context
        # This is set by the middleware
        return ctx.get_state("_session_manager")
    
    @staticmethod
    async def get_state(
        ctx: Context,
        key: str,
        default: Any = None
    ) -> Any:
        """Get state with appropriate scoping for current mode.
        
        Args:
            ctx: FastMCP context
            key: State key
            default: Default value if key not found
            
        Returns:
            State value or default
        """
        stateless_mode = ctx.get_state("stateless_mode")
        is_stateless = stateless_mode if stateless_mode is not None else False
        
        if is_stateless:
            # In stateless mode, use request-scoped state only
            result = ctx.get_state(f"request_{key}")
            return result if result is not None else default
        else:
            # In stateful mode, get from session manager directly
            session_id = ctx.get_state("session_id")
            if not session_id:
                logger.warning(f"No session ID available for stateful key: {key}")
                return default
            
            # Try to get session manager
            session_manager = StateAdapter._get_session_manager(ctx)
            if session_manager:
                session = session_manager.get_session(session_id)
                if session and "state" in session:
                    return session["state"].get(key, default)
            
            # Fallback to context-stored session data
            session_data = ctx.get_state(f"session_{session_id}_data")
            if session_data and "state" in session_data:
                return session_data["state"].get(key, default)
            
            return default
    
    @staticmethod
    async def set_state(
        ctx: Context,
        key: str,
        value: Any
    ) -> None:
        """Set state with appropriate scoping for current mode.
        
        Args:
            ctx: FastMCP context
            key: State key
            value: State value
        """
        stateless_mode = ctx.get_state("stateless_mode")
        is_stateless = stateless_mode if stateless_mode is not None else False
        
        logger.info(f"[StateAdapter.set_state] key={key}, is_stateless={is_stateless}")
        
        if is_stateless:
            # In stateless mode, store in request scope only
            ctx.set_state(f"request_{key}", value)
            logger.info(f"[StateAdapter.set_state] Stored in request scope: request_{key}")
        else:
            # In stateful mode, store in session manager
            session_id = ctx.get_state("session_id")
            logger.info(f"[StateAdapter.set_state] session_id={session_id}")
            
            if not session_id:
                logger.warning(f"No session ID available for stateful key: {key}")
                # Fall back to request scope
                ctx.set_state(f"request_{key}", value)
            else:
                # Get session manager and update session directly
                session_manager = StateAdapter._get_session_manager(ctx)
                logger.info(f"[StateAdapter.set_state] session_manager={session_manager is not None}")
                
                if session_manager:
                    session = session_manager.get_session(session_id)
                    logger.info(f"[StateAdapter.set_state] session exists={session is not None}")
                    
                    if session:
                        if "state" not in session:
                            session["state"] = {}
                        session["state"][key] = value
                        logger.info(f"[StateAdapter.set_state] Stored in session manager: {key} -> {value}")
                        # Also update context for current request
                        ctx.set_state(f"session_{session_id}_data", session)
                        return
                
                # Fallback: update context-stored session data
                logger.info("[StateAdapter.set_state] Using fallback to context-stored session data")
                session_data = ctx.get_state(f"session_{session_id}_data")
                if session_data:
                    if "state" not in session_data:
                        session_data["state"] = {}
                    session_data["state"][key] = value
                    ctx.set_state(f"session_{session_id}_data", session_data)
                    logger.info(f"[StateAdapter.set_state] Updated context session data with {key}")
                else:
                    # Create new session data
                    session_data = {"state": {key: value}}
                    ctx.set_state(f"session_{session_id}_data", session_data)
                    logger.info(f"[StateAdapter.set_state] Created new session data with {key}")
    
    @staticmethod
    async def delete_state(
        ctx: Context,
        key: str
    ) -> bool:
        """Delete state with appropriate scoping for current mode.
        
        Args:
            ctx: FastMCP context
            key: State key
            
        Returns:
            True if deleted, False if not found
        """
        stateless_mode = ctx.get_state("stateless_mode")
        is_stateless = stateless_mode if stateless_mode is not None else False
        
        if is_stateless:
            # In stateless mode, delete from request scope
            full_key = f"request_{key}"
            if ctx.get_state(full_key) is not None:
                ctx.set_state(full_key, None)
                return True
            return False
        else:
            # In stateful mode, delete from session manager
            session_id = ctx.get_state("session_id")
            if not session_id:
                logger.warning(f"No session ID available for stateful key: {key}")
                return False
            
            # Get session manager and update session directly
            session_manager = StateAdapter._get_session_manager(ctx)
            if session_manager:
                session = session_manager.get_session(session_id)
                if session and "state" in session and key in session["state"]:
                    del session["state"][key]
                    # Also update context
                    ctx.set_state(f"session_{session_id}_data", session)
                    return True
            
            # Fallback to context-stored session data
            session_data = ctx.get_state(f"session_{session_id}_data")
            if session_data and "state" in session_data and key in session_data["state"]:
                del session_data["state"][key]
                ctx.set_state(f"session_{session_id}_data", session_data)
                return True
            
            return False
    
    @staticmethod
    def list_state_keys(
        ctx: Context,
        pattern: Optional[str] = None
    ) -> list[str]:
        """List all state keys matching pattern.
        
        Args:
            ctx: FastMCP context
            pattern: Optional pattern to filter keys
            
        Returns:
            List of matching state keys
        """
        stateless_mode = ctx.get_state("stateless_mode")
        is_stateless = stateless_mode if stateless_mode is not None else False
        
        if is_stateless:
            logger.warning("list_state_keys is not fully implemented for stateless mode")
            return []
        else:
            session_id = ctx.get_state("session_id")
            if not session_id:
                return []
            
            # Get from session manager directly
            session_manager = StateAdapter._get_session_manager(ctx)
            if session_manager:
                session = session_manager.get_session(session_id)
                if session and "state" in session:
                    keys = list(session["state"].keys())
                    if pattern and pattern != "*":
                        import re
                        regex = pattern.replace("*", ".*")
                        keys = [k for k in keys if re.match(f"^{regex}$", k)]
                    return keys
            
            # Fallback to context
            session_data = ctx.get_state(f"session_{session_id}_data")
            if session_data and "state" in session_data:
                keys = list(session_data["state"].keys())
                if pattern and pattern != "*":
                    import re
                    regex = pattern.replace("*", ".*")
                    keys = [k for k in keys if re.match(f"^{regex}$", k)]
                return keys
            return []
    
    @staticmethod
    async def get_state_for_session(
        ctx: Context,
        session_id: str,
        key: str,
        default: Any = None
    ) -> Any:
        """Get state for a specific session (stateful mode only)."""
        stateless_mode = ctx.get_state("stateless_mode")
        if stateless_mode:
            logger.warning("get_state_for_session called in stateless mode")
            return default
        
        # Get from session manager
        session_manager = StateAdapter._get_session_manager(ctx)
        if session_manager:
            session = session_manager.get_session(session_id)
            if session and "state" in session:
                return session["state"].get(key, default)
        
        # Fallback
        session_data = ctx.get_state(f"session_{session_id}_data")
        if session_data and "state" in session_data:
            return session_data["state"].get(key, default)
        
        return default
    
    @staticmethod
    async def set_state_for_session(
        ctx: Context,
        session_id: str,
        key: str,
        value: Any
    ) -> None:
        """Set state for a specific session (stateful mode only)."""
        stateless_mode = ctx.get_state("stateless_mode")
        if stateless_mode:
            logger.warning("set_state_for_session called in stateless mode")
            return
        
        # Update session manager directly
        session_manager = StateAdapter._get_session_manager(ctx)
        if session_manager:
            session = session_manager.get_session(session_id)
            if session:
                if "state" not in session:
                    session["state"] = {}
                session["state"][key] = value
                # Also update context if current session
                if ctx.get_state("session_id") == session_id:
                    ctx.set_state(f"session_{session_id}_data", session)
                return
        
        # Fallback
        session_data = ctx.get_state(f"session_{session_id}_data")
        if session_data:
            if "state" not in session_data:
                session_data["state"] = {}
            session_data["state"][key] = value
            ctx.set_state(f"session_{session_id}_data", session_data)
    
    @staticmethod
    async def clear_session_state(
        ctx: Context,
        session_id: Optional[str] = None
    ) -> int:
        """Clear all state for a session."""
        stateless_mode = ctx.get_state("stateless_mode")
        if stateless_mode:
            logger.warning("clear_session_state called in stateless mode")
            return 0
        
        if not session_id:
            session_id = ctx.get_state("session_id")
        
        if not session_id:
            logger.warning("No session ID available for clearing state")
            return 0
        
        # Clear in session manager
        session_manager = StateAdapter._get_session_manager(ctx)
        if session_manager:
            session = session_manager.get_session(session_id)
            if session and "state" in session:
                count = len(session["state"])
                session["state"] = {}
                # Update context
                if ctx.get_state("session_id") == session_id:
                    ctx.set_state(f"session_{session_id}_data", session)
                return count
        
        # Fallback
        session_data = ctx.get_state(f"session_{session_id}_data")
        if session_data and "state" in session_data:
            count = len(session_data["state"])
            session_data["state"] = {}
            ctx.set_state(f"session_{session_id}_data", session_data)
            return count
        return 0
    
    @staticmethod
    def get_scope_prefix(ctx: Context) -> str:
        """Get the current state scope prefix."""
        stateless_mode = ctx.get_state("stateless_mode")
        is_stateless = stateless_mode if stateless_mode is not None else False
        
        if is_stateless:
            return "request_"
        else:
            session_id = ctx.get_state("session_id")
            if session_id:
                return f"session_{session_id}_"
            else:
                return "request_"  # Fallback to request scope
