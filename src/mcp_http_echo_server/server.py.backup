"""MCP Echo Server with dual-mode (stateful/stateless) support using FastMCP."""

import os
import logging
from typing import Optional
from fastmcp import FastMCP

from .session_manager import SessionManager
from .utils.state_adapter import StateAdapter
from .tools.echo_tools import register_echo_tools
from .tools.debug_tools import register_debug_tools
from .tools.auth_tools import register_auth_tools
from .tools.system_tools import register_system_tools
from .tools.state_tools import register_state_tools

logger = logging.getLogger(__name__)


class MCPEchoServer:
    """Dual-mode MCP Echo Server with comprehensive debugging tools."""
    
    SERVER_NAME = "mcp-http-echo-server"
    SERVER_VERSION = "1.0.0"
    PROTOCOL_VERSION = "2025-06-18"
    
    def __init__(
        self,
        stateless_mode: bool = False,
        session_timeout: int = 3600,
        debug: bool = False,
        supported_versions: Optional[list[str]] = None,
        adaptive_mode: bool = False
    ):
        """Initialize the MCP Echo Server.
        
        Args:
            stateless_mode: Run in stateless mode (no session persistence)
            session_timeout: Session timeout in seconds (stateful mode only)
            debug: Enable debug logging
            supported_versions: List of supported protocol versions
            adaptive_mode: Enable adaptive mode (auto-detect per request)
        """
        self.stateless_mode = stateless_mode
        self.adaptive_mode = adaptive_mode
        self.debug = debug
        self.supported_versions = supported_versions or [self.PROTOCOL_VERSION]
        self.session_timeout = session_timeout
        
        # Create FastMCP instance
        if adaptive_mode:
            mode_desc = "adaptive (auto-detect)"
            mode_info = "ADAPTIVE - Automatically detects stateful/stateless based on client behavior"
        elif stateless_mode:
            mode_desc = "stateless"
            mode_info = "STATELESS - No session persistence"
        else:
            mode_desc = "stateful"
            mode_info = "STATEFUL - Full session management"
        
        self.mcp = FastMCP(
            name=self.SERVER_NAME,
            version=self.SERVER_VERSION,
            instructions=f"""A {mode_desc} MCP echo server with 21 comprehensive debugging tools.
            
Mode: {mode_info}
Protocol: {', '.join(self.supported_versions)}
            
Available tool categories:
- Echo Tools: echo, replayLastEcho
- Debug Tools: printHeader, requestTiming, corsAnalysis, environmentDump
- Auth Tools: bearerDecode, authContext, whoIStheGOAT
- System Tools: healthProbe, sessionInfo
- State Tools: stateInspector, sessionHistory, stateManipulator, sessionCompare, 
               sessionTransfer, stateBenchmark, sessionLifecycle, stateValidator,
               requestTracer, modeDetector"""
        )
        
        # Initialize session manager (always available for adaptive mode)
        # In adaptive mode, we need the session manager ready for stateful clients
        self.session_manager = SessionManager(session_timeout) if (not stateless_mode or adaptive_mode) else None
        
        # Register middleware
        self._register_middleware()
        
        # Register all tools
        self._register_tools()
        
        if debug:
            if adaptive_mode:
                logger.info("MCP Echo Server initialized in ADAPTIVE mode")
            else:
                logger.info(
                    "MCP Echo Server initialized in %s mode",
                    "STATELESS" if stateless_mode else "STATEFUL"
                )
    
    def _register_middleware(self):
        """Register middleware for request processing."""
        from fastmcp.server.middleware import Middleware
        import time
        import uuid
        
        # Create custom middleware class for mode-specific behavior
        class ModeMiddleware(Middleware):
            def __init__(self, server_instance):
                self.server = server_instance
                super().__init__()
            
            async def on_message(self, ctx, call_next):
                """Set up mode-specific behavior and request context."""
                # Get the FastMCP context from middleware context
                if ctx.fastmcp_context:
                    fc = ctx.fastmcp_context
                    
                    # Detect mode per-request if in adaptive mode
                    if self.server.adaptive_mode:
                        # Check for session indicators:
                        # 1. FastMCP internal session (most common)
                        # 2. Session headers (for custom clients)
                        has_session = False
                        
                        # First check if FastMCP has an internal session
                        if hasattr(fc, "session_id") and fc.session_id:
                            has_session = True
                            if self.server.debug:
                                logger.debug(f"Detected FastMCP session: {fc.session_id}")
                        
                        # Also check for session headers as fallback
                        if not has_session and hasattr(fc, "_request") and hasattr(fc._request, "headers"):
                            headers = fc._request.headers
                            has_session = "mcp-session-id" in headers or "Mcp-Session-Id" in headers
                            if has_session and self.server.debug:
                                logger.debug("Detected session header")
                        
                        # Use stateful mode if any session indicator exists
                        is_stateless = not has_session
                        fc.set_state("stateless_mode", is_stateless)
                        
                        if self.server.debug:
                            mode = "stateless" if is_stateless else "stateful"
                            logger.debug(f"Adaptive mode: Using {mode} mode for this request")
                    else:
                        # Use fixed mode
                        fc.set_state("stateless_mode", self.server.stateless_mode)
                    
                    # Set server config in context
                    fc.set_state("server_debug", self.server.debug)
                    fc.set_state("server_name", self.server.SERVER_NAME)
                    fc.set_state("server_version", self.server.SERVER_VERSION)
                    fc.set_state("supported_versions", self.server.supported_versions)
                    fc.set_state("adaptive_mode", self.server.adaptive_mode)
                    
                    # Store request-scoped data (works in both modes)
                    fc.set_state("request_start_time", time.time())
                    request_id = str(uuid.uuid4())
                    if hasattr(fc, "request_id") and fc.request_id:
                        request_id = fc.request_id
                    fc.set_state("request_id", request_id)
                
                    # Extract and store headers if available
                    if hasattr(fc, "_request") and hasattr(fc._request, "headers"):
                        headers = dict(fc._request.headers)
                        fc.set_state("request_headers", headers)
                
                    # Check if we should use stateful mode for this request
                    is_stateless = fc.get_state("stateless_mode")
                    if not is_stateless and self.server.session_manager:
                        # Stateful mode: manage sessions
                        session_id = None
                        
                        # Try to get session ID from headers or context
                        if hasattr(fc, "session_id") and fc.session_id:
                            session_id = fc.session_id
                        elif hasattr(fc, "_request") and hasattr(fc._request, "headers"):
                            session_id = fc._request.headers.get("mcp-session-id")
                        
                        # Create or get session
                        if not session_id:
                            session_id = self.server.session_manager.create_session()
                            if self.server.debug:
                                logger.debug(f"Created new session: {session_id}")
                        
                        # Store session ID in context
                        fc.set_state("session_id", session_id)
                        
                        # Update session activity
                        session = self.server.session_manager.get_session(session_id)
                        if session:
                            session["last_activity"] = time.time()
                            session["request_count"] = session.get("request_count", 0) + 1
                            
                            # Store session data in context for easy access
                            fc.set_state(f"session_{session_id}_data", session)
                
                    # Track request in history (for both modes)
                    if fc:
                        await self.server._track_request(fc)
                
                # Call next handler
                result = await call_next(ctx)
                
                # Track response
                if ctx.fastmcp_context:
                    await self.server._track_response(ctx.fastmcp_context, result)
                
                return result
        
        # Create error handling middleware class
        class ErrorHandlingMiddleware(Middleware):
            def __init__(self, server_instance):
                self.server = server_instance
                super().__init__()
            
            async def on_message(self, ctx, call_next):
                """Handle errors gracefully."""
                try:
                    return await call_next(ctx)
                except Exception as e:
                    logger.error(f"Error processing request: {e}", exc_info=True)
                    
                    # Track error in context
                    if ctx.fastmcp_context:
                        errors = ctx.fastmcp_context.get_state("request_errors") or []
                        errors.append({
                            "error": str(e),
                            "type": type(e).__name__,
                            "timestamp": time.time()
                        })
                        ctx.fastmcp_context.set_state("request_errors", errors)
                    
                    raise
        
        # Add middleware to the FastMCP server
        self.mcp.add_middleware(ModeMiddleware(self))
        self.mcp.add_middleware(ErrorHandlingMiddleware(self))
    
    async def _track_request(self, ctx):
        """Track request in history."""
        import time
        
        # Build request event
        event = {
            "timestamp": time.time(),
            "event": "request_received",
            "request_id": ctx.get_state("request_id"),
            "mode": "stateless" if ctx.get_state("stateless_mode") else "stateful"
        }
        
        # Add session info if stateful
        if not self.stateless_mode:
            event["session_id"] = ctx.get_state("session_id")
        
        # Store in appropriate history
        is_stateless = ctx.get_state("stateless_mode")
        if is_stateless:
            # In stateless mode, only track in request scope
            ctx.set_state("request_history", [event])
        else:
            # In stateful mode, add to session history
            history = await StateAdapter.get_state(ctx, "session_history", [])
            history.append(event)
            await StateAdapter.set_state(ctx, "session_history", history)
    
    async def _track_response(self, ctx, result):
        """Track response in history."""
        import time
        
        # Calculate timing
        start_time = ctx.get_state("request_start_time")
        elapsed = (time.time() - start_time) * 1000 if start_time else 0
        
        # Build response event
        event = {
            "timestamp": time.time(),
            "event": "response_sent",
            "request_id": ctx.get_state("request_id"),
            "elapsed_ms": elapsed
        }
        
        # Add to history if stateful
        is_stateless = ctx.get_state("stateless_mode")
        if not is_stateless:
            history = await StateAdapter.get_state(ctx, "session_history", [])
            history.append(event)
            await StateAdapter.set_state(ctx, "session_history", history)
    
    def _register_tools(self):
        """Register all tools with the server."""
        # Register tool groups
        # In adaptive mode, tools determine their mode at runtime
        # Pass False to enable all tools, they'll check context for actual mode
        is_stateless_init = self.stateless_mode and not self.adaptive_mode
        register_echo_tools(self.mcp, is_stateless_init)
        register_debug_tools(self.mcp, is_stateless_init)
        register_auth_tools(self.mcp, is_stateless_init)
        register_system_tools(self.mcp, is_stateless_init, self.session_manager)
        register_state_tools(self.mcp, is_stateless_init)
        
        if self.debug:
            # Count registered tools
            tool_count = len(self.mcp._tool_manager._tools) if hasattr(self.mcp, "_tool_manager") else 0
            logger.info(f"Registered {tool_count} tools")
    
    def run(
        self,
        host: str = "0.0.0.0",
        port: int = 3000,
        transport: str = "http",
        **kwargs
    ):
        """Run the MCP server.
        
        Args:
            host: Host to bind to
            port: Port to bind to
            transport: Transport type (http, stdio, sse)
            **kwargs: Additional transport-specific options
        """
        if self.adaptive_mode:
            mode_str = "ADAPTIVE"
        else:
            mode_str = "STATELESS" if self.stateless_mode else "STATEFUL"
        logger.info(
            "Starting %s in %s mode on %s:%d with %s transport",
            self.SERVER_NAME,
            mode_str,
            host,
            port,
            transport
        )
        
        # Configure transport options
        transport_options = {
            "host": host,
            "port": port,
            **kwargs
        }
        
        # For HTTP transport, set stateless mode
        if transport == "http":
            transport_options["stateless_http"] = self.stateless_mode
        
        # Run the server
        self.mcp.run(
            transport=transport,
            **transport_options
        )


def create_server(
    stateless_mode: bool = False,
    session_timeout: int = 3600,
    debug: bool = False,
    supported_versions: Optional[list[str]] = None
) -> MCPEchoServer:
    """Factory function to create an MCP Echo Server instance.
    
    Args:
        stateless_mode: Run in stateless mode
        session_timeout: Session timeout in seconds
        debug: Enable debug logging
        supported_versions: List of supported protocol versions
    
    Returns:
        MCPEchoServer instance
    """
    return MCPEchoServer(
        stateless_mode=stateless_mode,
        session_timeout=session_timeout,
        debug=debug,
        supported_versions=supported_versions
    )